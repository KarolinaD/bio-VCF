\chapter{Bio.VCF: handling VCF and phased files}

Since new functionality added to \verb|Biopython| version ILEŚTAM NAPISAĆ ILE BO NIE WIEM is based on \verb|pyVCF|
package, this chapter is partly based on the original \verb|pyVCF| documentation. Not all of the original functionality
is described below, therefore for further details of \verb|Bio.VCF| module, pleas see
\href{http://pyvcf.readthedocs.io/en/latest/INTRO.html}{pyVCF}.

\section{VCF.Reader class}

\verb|Bio.VCF.Reader| class takes a file-like object and acts as reader. It is intended to parse the content of each record
based on the data types specified in the meta-information lines – specifically the \verb|##INFO| and \verb|##FORMAT| lines.
If these lines are missing or incomplete it will check against the reserved types mentioned in the spec.
Failing that, it will just return strings.

\noindent The attributes of a \verb|Record| object are the 8 fixed fields from the VCF spec: \

\

\verb|Record.CHROM|, \verb|Record.POS|, \verb|Record.ID|, \verb|Record.REF|, \verb|Record.ALT|, \verb|Record.QUAL| \
  \verb|Record.FILTER|, \verb|Record.INFO|

\

\noindent plus attributes to handle genotype information:

\

\verb|Record.FORMAT|, \verb|Record.samples|, \verb|Record.genotype|.

\

\noindent Regarding the coordinates associated with each instance:

\begin{description}
  \item[\texttt{POS}] \

    per VCF specification, is the one-based index (the first base of the contig has an index of 1)
    of the first base of the \verb|REF| sequence

  \item[\texttt{start}{ end}] \

    denote the coordinates of the entire \verb|REF| sequence in the zero-based, half-open coordinate
    system (see \href{http://genomewiki.ucsc.edu/index.php/Coordinate_Transforms}{Coordinate\_Transforms}), where
    the first base of the contig has an index of 0, and the interval runs up to, but does not include, the base
    at the end index. This indexing scheme is analagous to Python slice notation.

  \item[\texttt{affected\_start}{ affected\_end}] \

    are also in the zero-based, half-open coordinate system. These coordinates indicate the precise region
    of the reference genome actually affected by the events denoted in \verb|ALT| (i.e., the minimum
    \verb|affected_start| and maximum \verb|affected_end|).
    For SNPs and structural variants, the affected region includes all bases of \verb|REF|, including the
    first base (i.e., \verb|affected_start| = \verb|start| = \verb|POS| - 1).
    For deletions, the region includes all bases of \verb|REF| except the first base, which flanks
    upstream the actual deletion event, per VCF specification.
    For insertions, the \verb|affected_start| and \verb|affected_end| coordinates represent a
    0 bp-length region between the two flanking bases (i.e., \verb|affected_start| = \verb|affected_end|).
    This is analagous to Python slice notation (see \href{http://stackoverflow.com/a/2947881/38140}{Stackoverflow}).
    Neither the upstream nor downstream flanking bases are included in the region.

\end{description}

\noindent \verb|samples| and \verb|genotype|, not being the title of any column, are left lowercase. The format of the fixed
fields is from the spec. Comma-separated lists in the \verb|VCF| are converted to lists. In particular,
one-entry \verb|VCF| lists are converted to one-entry Python lists (see, e.g., \verb|Record.ALT|).
Semicolon-delimited lists of key=value pairs are converted to Python dictionaries, with flags being given a True value.


\noindent This module supports


\noindent Metadata regarding the VCF file itself can be investigated through the following attributes:

\

\verb|Record.metadata|, \verb|Record.infos|, \verb|Record.filters|, \verb|Record.formats|, \verb|Record.samples|.

\



\noindent Suppose we have a VCF file and want to see all the records in it. We might simply create a Bio.VCF.Reader object:

\begin{verbatim}
>>> from Bio.VCF import parser
>>> vcf_reader = parser.Reader(open('VCF/example-4.0.vcf', 'r'))
>>> for record in vcf_reader:
...     print record
Record(CHROM=20, POS=14370, REF=G, ALT=[A])
Record(CHROM=20, POS=17330, REF=T, ALT=[A])
Record(CHROM=20, POS=1110696, REF=A, ALT=[G, T])
Record(CHROM=20, POS=1230237, REF=T, ALT=[None])
Record(CHROM=20, POS=1234567, REF=GTCT, ALT=[G, GTACT])
\end{verbatim}


\noindent Now, we are interested in position and alteration type of the first record from the VCF file. We can
obtain the information by typing:

\begin{verbatim}
>>> record = next(vcf_reader)
>>> print record.POS
14370
>>> print record.ALT
[A]
>>> print record.INFO['AF']
[0.5]
\end{verbatim}

\noindent Moreover there are a number of convenience methods and properties for each \verb|Bio.VCF.Record| object
allowing you to examine properties of interest:

\begin{verbatim}
>>> print record.num_called, record.call_rate, record.num_unknown
3 1.0 0
>>> print record.num_hom_ref, record.num_het, record.num_hom_alt
1 1 1
>>> print record.nucl_diversity, record.aaf, record.heterozygosity
0.6 [0.5] 0.5
>>> print record.get_hets()
[Call(sample=NA00002, CallData(GT=1|0, GQ=48, DP=8, HQ=[51, 51]))]
>>> print record.is_snp, record.is_indel, record.is_transition, record.is_deletion
True False True False
>>> print record.var_type, record.var_subtype
snp ts
>>> print record.is_monomorphic
False
\end{verbatim}

\verb|record.FORMAT| will be a string specifying the format of the genotype fields. In case the \verb|FORMAT|
 column does not exist, \verb|record.FORMAT| is None. Finally, \verb|record.samples| is a list of dictionaries
 containing the parsed sample column and \verb|record.genotype| is a way of looking up genotypes by sample name:

 \begin{verbatim}
>>> record = next(vcf_reader)
>>> for sample in record.samples:
...     print sample['GT']
0|0
0|1
0/0
>>> print record.genotype('NA00001')['GT']
0|0
\end{verbatim}

\noindent The genotypes are represented by \verb|Call| objects, which have three attributes: the corresponding \verb|Record|
\verb|site|, the sample name in \verb|sample| and a dictionary of call data in \verb|data|:

\begin{verbatim}
>>> call = record.genotype('NA00001')
>>> print call.site
Record(CHROM=20, POS=17330, REF=T, ALT=[A])
>>> print call.sample
NA00001
>>> print call.data
CallData(GT=0|0, GQ=49, DP=3, HQ=[58, 50])
\end{verbatim}

\noindent There are also a number of methods for \verb|Call| objects:

\begin{verbatim}
>>> print call.called, call.gt_type, call.gt_bases, call.phased
True 0 T|T True
\end{verbatim}

\noindent User can be interested in some details of the VCF file, for example file's creation date, samples included
and filters. The functionality of this module supports retrieval of such data:

\begin{verbatim}
>>> vcf_reader.metadata['fileDate']
'20090805'
>>> vcf_reader.samples
['NA00001', 'NA00002', 'NA00003']
>>> vcf_reader.filters
OrderedDict([('q10', Filter(id='q10', desc='Quality below 10')), \
('s50', Filter(id='s50', desc='Less than 50% of samples have data'))])
>>> vcf_reader.infos['AA'].desc
'Ancestral Allele'
\end{verbatim}

\noindent When you are interested in \verb|ALT| records, you can interrogate them to achieve information:

\begin{verbatim}
>>> reader = parser.Reader(open('VCF/example-4.1-bnd.vcf'))
>>> _ = next(reader); row = next(reader)
>>> print row
Record(CHROM=1, POS=2, REF=T, ALT=[T[2:3[])
>>> bnd = row.ALT[0]
>>> print bnd.withinMainAssembly, bnd.orientation, bnd.remoteOrientation, bnd.connectingSequence
True False True T
\end{verbatim}

\subsection{Record parameters}

\noindent Below there is a brief description of other methods and parameters available for Reader's records.

\begin{description}
  \item[\texttt{aaf}] \

   A list of allele frequencies of alternate alleles. NOTE: Denominator calc’ed from \_called\_ genotypes.

  \item[\texttt{alleles}] \

   list of alleles. [0] = REF, [1:] = ALTS

  \item[\texttt{call\_rate}] \

  The fraction of genotypes that were actually called.

  \item[\texttt{end}] \

  zero-based, half-open end coordinate of \verb|REF|.

  \item[\texttt{get\_hets()}] \

    The list of het genotypes.

  \item[\texttt{get\_hom\_alts()}] \

    The list of hom alt genotypes.

  \item[\texttt{get\_hom\_refs()}] \

    The list of hom ref genotypes.

  \item[\texttt{heterozygosity}] \

    Heterozygosity of a site. Heterozygosity gives the probability that two randomly chosen chromosomes from the
    population have different alleles, giving a measure of the degree of polymorphism in a population.
    If there are i alleles with frequency p\_i, H=1-sum\_i(p\_i\^2)

\end{description}

\noindent There are also a number of boolean methods, such as:

\verb|is_deletion|, \verb|is_filtered|, \verb|is_indel|, \verb|is_monomorphic|, \verb|is_snp|, \verb|is_svp|, \verb|is_transition|.

\subsection{Additional utilities}

\noindent Below there is a brief description of additional utilities for VCF files.


\begin{description}

    \item[\texttt{utils.walk\_together(*readers, **kwargs)}] \

    Simultaneously iteratate over two or more \verb|VCF| readers. For each genomic position with a variant,
    return a list of size equal to the number of VCF readers. This list contains the \verb|VCF| record from
    readers that have this variant, and None for readers that don’t have it. The caller must make sure
    that inputs are sorted in the same way and use the same reference otherwise behaviour is undefined.

    \verb|Args|:
            \verb|vcf_record_sort_key|: \

    function that takes a VCF record and returns a
    tuple that can be used as a key for comparing and sorting \verb|VCF| records across all readers.
    This tuple defines what it means for two variants to be equal (eg. whether it’s only their
    position or also their allele values), and implicitly determines the chromosome ordering since
    the tuple’s 1st element is typically the chromosome name (or calculated from it).


    \item[\texttt{vcf.utils.trim\_common\_suffix(*sequences)}] \

    Trim a list of sequences by removing the longest common suffix while leaving all of them at least one
    character in length. Standard convention with VCF is to place an indel at the left-most position,
    but some tools add additional context to the right of the sequences (e.g. samtools).
    These common suffixes are undesirable when comparing variants, for example in variant databases.

    \begin{verbatim}
    >>> trim_common_suffix('TATATATA', 'TATATA')
    ['TAT', 'T']
    \end{verbatim}


    \begin{verbatim}
    >>> trim_common_suffix('ACCCCC', 'ACCCCCCCC', 'ACCCCCCC', 'ACCCCCCCCC')
    ['A', 'ACCC', 'ACC', 'ACCCC']
    \end{verbatim}

    \

    \item[\texttt{vcf\_melt}] \

    This script converts a \verb|VCF| file from wide format (many calls per row) to a long format
    (one call per row). This is useful if you want to grep per sample or for really quick
    import into, say, a spreadsheet:

    \begin{verbatim}
    $ vcf_melt < vcf/test/gatk.vcf
    SAMPLE      AD      DP      GQ      GT      PL      FILTER  CHROM   POS     REF     ...
    BLANK       6,0     6       18.04   0/0     0,18,211        .       chr22   42522392        ...
    NA12878     138,107 250     99.0    0/1     1961,0,3049     .       chr22   42522392        ...
    NA12891     169,77  250     99.0    0/1     1038,0,3533     .       chr22   42522392        ...
    NA12892     249,0   250     99.0    0/0     0,600,5732      .       chr22   42522392        ...
    ...
    \end{verbatim}

    \end{description}

\section{VCF.Writer class}

\noindent The \verb|Bio.VCF.Writer| class provides a way of writing a VCF file.
\verb|Bio.VCF.parser| module supports \verb|close()|, \verb|flush()| and \verb|write_record()| methods.

\noindent Currently, when writing new VCF file you must specify a template \verb|Bio.VCF.Reader| object
which provides the metadata, like this:

\begin{verbatim}
>>> from Bio.VCF import parser
>>> vcf_reader = parser.Reader(filename='VCF/tb.vcf.gz')
>>> vcf_writer = parser.Writer(open('/dev/null', 'w'), vcf_reader)
>>> for record in vcf_reader:
...     vcf_writer.write_record(record)
\end{verbatim}




\section{Retrieving records from VCF file}

\noindent This chapter gives an overview of the functionality of fetch methods included in \verb|Bio.VCF| \verb|parser| module.
Those functions enable users to retrieve particular records from VCF file describing structural variants,
depending on provided argument - for example interval of positions within which we seek for structural variants, a list
of such positions or feature type within which structural variants are present.


\noindent Functionality of those fetch methods includes retrieving structural variants corresponding to ranges
provided in BED files as well as features from GFF files. If you are not familiar with BED file format
you might be interested in \href{http://www.ensembl.org/info/website/upload/bed.html}{BED} and
\href{http://gmod.org/wiki/GFF3}{GFF}.


\noindent Most of implementation is based on \verb|pybedtools| module - \href{https://daler.github.io/pybedtools/}{pybedtools},
which support many file formats including VCF, BED and GFF, therefore \verb|pybedtools| package is required.


\noindent Due to enormous sizes of some BED and GFF files, some fetch methods are intended to enable user to provide
stream of particular GFF/BED file from chosen database. It is a beneficial solution allowing users to avoid
the necessity of saving very big files to local disc.


\noindent Below there is a brief description of each fetch method.
All of them have arguments \verb|verbose| and \verb|vcf| specifying if result should be printed to stdout
and whether new VCF.Reader object should be created, respectively.

\begin{description}
  \item[\texttt{fetch\_bed(bed\_file, verbose = True, vcf = None)}] \

    Fetches VCF file records that correspond to regions included in a BED file.
    Fetch is based on pybedtools 'intersect' method and returns a BedTool / VCF.Reader object of selected features.
    BED file must be specified.

  \item[\texttt{fetch\_bed\_fsock(stream, verbose = False, vcf=None)}] \

    This fetch works exactly the same as fetch\_bed(), except the BED file is not required.
    Intervals used for intersection with a VCF file are provided in stream object of chosen BED file.
    This method returns a BedTool object of selected VCF features or new VCF.Reader object.
    Stream of gzipped BED file is required.

  \item[\texttt{fetch\_multilocal(chrom, local\_list, verbose = False, vcf = None)}] \

    Fetches VCF records that correspond to intervals provided in 'local\_list'.
    Local\_list must be a list of tuples (start, end), where start and end coordinates are in the
    zero-based, half-open coordinate system. Function returns selected records as a BedTool object
    or new VCF.Reader object. Chromosome must be specified.

  \item[\texttt{fetch(chrom, interval = None, verbose = True, vcf=None)}] \

    Fetches those records from VCF file that correspond to selected chromosome and
    fit in selected interval (if provided).
    This method creates one-line pybedtool feature based on selected chromosome (and interval = [start,stop]),
    and then uses it in pybedtools intersection method.
    Function returns BedTool object representing selected VCF records or new VCF.Reader object.
    Chromosome must be specified and interval is optional.

  \item[\texttt{fetch\_gff(gff\_file, chrom, feature\_type, location = None, verbose = False, vcf = None)}] \

    This method enables to select desired features from a GFF/GFF2/GFF3 file and fetch VCF records
    that correspond to position of those features. Fetch is based on pybedtools 'intersection' method and returns
    a BedTool object of chosen VCF records or new VCF.Reader object.
    Gff file, chromosome and feature type are required.
    Selection of desired features from a GFF/GFF2/GFF3 file with a specified location is possible when
    provided optional parameter 'location=[start,end]'.

  \item[\texttt{fetch\_gff\_fsock(self, stream, chrom, feature\_type, location = None, verbose = False, vcf = None)}] \

    This method works exactly the same as fetch\_gff(), except the GFF file is not required.
    The GFF file is replaced with a stream object from chosen database.
    Method returns a BedTool object of selected VCF records or new VCF.Reader object.
    Stream of gzipped file must be provided.

\end{description}


\noindent The following sections present exemplary use of fetch methods.


\subsection{Create VCF.Reader object}
\label{sec:object}


\noindent Since all fetch methods are included in VCF.Reader class, we need to create \verb|Reader| object. But first of all,
we need to import Bio.VCF library:


\begin{verbatim}
>>> from Bio import VCF
>>> from VCF import parser

\end{verbatim}

and then create a VCF.Reader obcject. We can either create object from a local file or we can provide fsock
of corresponding VCF file:


\begin{verbatim}
>>> vcf=parser.Reader(open('Tests/VCF/chr13.vcf'))

\end{verbatim}

\subsubsection{Fetching records depending on BED/GFF file}


\noindent Suppose we have a BED file with positions of CTCF motif binding sites. We want to collect all structural variants
located within those sites. If we have this BED file locally on our computer, then we should simply run:


\begin{verbatim}
>>> vcf.fetch_bed('VCF/chr13bed.bed')

\end{verbatim}


or if we don't, we should provide a stream of chosen BED file and use:


\begin{verbatim}
>>> stream="ftp://ftp.ncbi.nih.gov/snp/organisms/human_9606/BED/bed_chr_13.bed.gz"
>>> vcf.fetch_bed_fsock(stream)

\end{verbatim}


\noindent Selected structural variants are returned in BedTools object (if vcf = None) and can be easily accessed, for example
if we want to see all information of every selected record:


\begin{verbatim}
>>> bed = vcf.fetch_bed('VCF/chr13bed.bed')
>>> for b in bed:
>>>     print (b.fields)
['chr13', '10', '.', 'G', 'GGT', '.', 'PASS', 'DP=91;SS=1;SSC=2;GPV=3.0109E-23;SPV=5.8324E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','0/1:.:36:13:22:62.86%:2,11,1,21']
['chr13', '20', '.', 'GT', 'G', '.', 'PASS', 'DP=77;SS=1;SSC=2;GPV=2.4504E-29;SPV=6.0772E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','1/1:.:28:5:22:81.48%:0,5,1,21']
['chr13', '40', '.', 'AAAC', 'A', '.', 'PASS', 'DP=42;SS=1;SSC=12;GPV=7.3092E-18;SPV=6.278E-2',
'GT:GQ:DP:RD:AD:FREQ:DP4','0/1:.:13:4:9:69.23%:4,0,9,0']
['chr13', '50', '.', 'TC', 'T', '.', 'PASS', 'DP=41;SS=1;SSC=2;GPV=9.8874E-23;SPV=5.3659E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','1/1:.:22:1:21:95.45%:1,0,15,6']
['chr13', '60', '.', 'T', 'TTAA', '.', 'PASS', 'DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1',
'GT:GQ:DP:RD:AD:FREQ:DP4','1/1:.:12:0:12:100%:0,0,0,12']
\end{verbatim}


\noindent Similarly, we can extract structural variants corresponding to positions of chosen features from GFF file. Suppose
we have a GFF3 file of Homo sapiens, but we are interested only in variants located within pseudogenes
at 13th chromosome. \verb|fetch_gff()| method is what we need:


\begin{verbatim}
>>> vcf.fetch_gff('VCF/HS_fetch_gff.gff3', '13', 'pseudogene')
\end{verbatim}


\noindent What is more, if we want variant within pseudogenes which are within specific positions, we can add
\verb|location| argument:


\begin{verbatim}
>>> vcf.fetch_gff('VCF/HS_fetch_gff.gff3', '13', 'pseudogene', location=[1, 18270822])
Finding SV corresponding to pseudogene and chosen position
chr13	20	.	GT	G	.	PASS	DP=77;SS=1;SSC=2;GPV=2.4504E-29;SPV=6.0772E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:28:5:22:81.48%:0,5,1,21
chr13	30	.	AC	A	.	PASS	DP=22;SS=1;SSC=7;GPV=1.3117E-10;SPV=1.9481E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:10:2:8:80%:0,2,0,8
chr13	40	.	AAAC	A	.	PASS	DP=42;SS=1;SSC=12;GPV=7.3092E-18;SPV=6.278E-2	GT:GQ:DP:RD:AD:FREQ:DP4
0/1:.:13:4:9:69.23%:4,0,9,0
chr13	50	.	TC	T	.	PASS	DP=41;SS=1;SSC=2;GPV=9.8874E-23;SPV=5.3659E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:22:1:21:95.45%:1,0,15,6
chr13	60	.	T	TTAA	.	PASS	DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:12:0:12:100%:0,0,0,12
chr13	9542346	.	T	TTAA	.	PASS	DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:12:0:12:100%:0,0,0,12
\end{verbatim}


\noindent As in case of fetch depending on BED file, we can use stream of GFF file instead of local file.


\subsubsection{Fetching records depending on interval}


\noindent We might have a VCF file which have records referring to different chromosomes. In such case, we want to be able to
analyze only those variants that are located on chromosome of our interest. We can simply use \verb|fetch()| method
on our \verb|vcf| object, but as we want to analyze fetched records further, we should use argument specifying
new vcf.Reader object:


\begin{verbatim}
>>> v=vcf.fetch('chr13',vcf='new_vcf')
>>> v
<parser.Reader object at 0x7eff4df8f2b0>

\end{verbatim}


\noindent Now, when we have all variants located on chromosome 13, we can choose only those within specified intervals:


\begin{verbatim}
>>> v.fetch_multilocal('chr13',[[10, 30], [80, 100], [85837129, 100000000]])
chr13	20	.	GT	G	.	PASS	DP=77;SS=1;SSC=2;GPV=2.4504E-29;SPV=6.0772E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:28:5:22:81.48%:0,5,1,21
chr13	30	.	AC	A	.	PASS	DP=22;SS=1;SSC=7;GPV=1.3117E-10;SPV=1.9481E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:10:2:8:80%:0,2,0,8
chr13	85837130	.	T	TTAA	.	PASS	DP=27;SS=1;SSC=2;GPV=1.4382E-14;SPV=5.5556E-1	GT:GQ:DP:RD:AD:FREQ:DP4
1/1:.:12:0:12:100%:0,0,0,12
<BedTool(/tmp/pybedtools.dbyw5lct.tmp)>

\end{verbatim}


\noindent VCF file created after \verb|vcf.fetch| is saved to local disc and can be easily achieved with
VCF.Reader() anytime needed.

\section{Available VCF Databases}

\noindent Bio.VCF.databases is a Biopython module that supports \verb|1001 Genomes| and \verb|dbSNP| databases.
Since most of VCF files are of enormous sizes, it is convenient to use streams instead of local files.
Functionality of this package enables users to search through above-mentioned databases, and use selected streams
of VCF files as VCF.Reader objects in further analysis.


\noindent If you are not familiar with \verb|1001 Genomes| and \verb|dbSNP| databases you might be interested in
\href{http://1001genomes.org/}{1001 Genomes} and \href{https://www.ncbi.nlm.nih.gov/SNP/}{dbSNP}. However, following
sections provide brief description of methods searching through both databases as well as some information about them.


\subsection{1001 Genomes database}
\label{sec:object}


\verb|1001 Genomes| database was launched to discover whole-genome variation of the \verb|Arabidopsis Thaliana| strains.
\verb|Bio.VCf.databases| module supports current database's version which includes analysis of 1135 genomes achieved
during the first phase of the project.
Searching through the database can be based on strain's name, ec number, eco type, as well as on information of its
origin - such as country, longitude or latitude.


\noindent Below there is a brief description of \verb|thousandgenome()| methods:


\begin{description}
  \item[\texttt{thousandgenomes(name, ecotype, ecnumber, country, longitude, latitude)}] \

    This method enables to search through \verb|1001 Genomes| database for VCF file corresponding to selected
    Arabidopsis Thaliana strain, origin country or longitude and/or latitude where Arabidopsis Thaliana live.

    Country name must be chosen from: "USA", "FRA", "CZE", "AUT", "KGZ", "TJK", "SWE", "UK", "GER", "KAZ",
    "BEL", "CPV", "ESP", "RUS", "NED", "FIN", "SUI", "ITA", "IRL", "POR", "EST", "DEN", "IND", "LTU", "JPN", "POL", "NOR",
    "CAN", "UKR", "AZE", "GEO", "ARM", "MAR", "CRO", "BUL", "GRC", "SVK", "ROU", "UZB", "SRB", "CHN", "IRN", "LBN", "MAR",
    "AFG".
    Longitude and latitude should be provided as an interval - longitude = (int1, int2), latitude = (int1,int2).
    Strain names, eco types and ec numbers are unique, country, while longitude and latitude enables users to seek for
    multiple VCF files corresponding to selected features.
    Method returns VCF.Reader object of selected VCF file stream from 1001 Genomes Database or a list of
    such VCF.Reader objects.

\item[\texttt{download(vcf\_reader, path\_filename)}] \

    Downloads VCF file corresponding to stream on which provided VCF.Reader object is initialized.
    VCF.Reader object as well as download directory and filename are required.


\end{description}

\noindent Let's try some functionality of the module:

\noindent Suppose we want to analyse structural variants identified in "CYR" strain of Arabidopsis Thaliana. First of all,
we need to find VCF file corresponding to our selected strain. To do so, we can simply type:


\begin{verbatim}
>>> from Bio.VCF import databases
>>> vcf = databases.thousandgenomes("CYR")
>>> vcf
<Bio.VCF.parser.Reader object at 0x7f4bf49feef0>

\end{verbatim}


\noindent Now, we can continue analysis for example by running methods from VCF.Reader class.


\noindent We may also be interested in retrieving all structural variants that are identified in strains occupying a particular
territory, such as area of longitude (-73.1494, -73.1492) and latitude (40.9063, 40.9064). Module's \verb|thousandgenomes()|
method can manage this:


\begin{verbatim}
>>> vcf_list = databases.thousandgenomes(longitude=(-73.1494, -73.1492), latitude=(40.9063, 40.9064))
>>> vcf_list
[<Bio.VCF.parser.Reader object at 0x7f4bf4a0d978>, <Bio.VCF.parser.Reader object at 0x7f4bf4a1e080>]

\end{verbatim}


\noindent Method returned two VCF.Reader objects which we can analyse further or simply download to local disc:


\begin{verbatim}
>>> for v in vcf_list:
>>>     databases.download(v,'database_download.gz')
\end{verbatim}

\subsection{dbSNP database}
todo Zojka